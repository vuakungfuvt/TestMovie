//
// This is a generated file, do not edit!
// Generated by R.swift, see https://github.com/mac-cain13/R.swift
//

import Foundation
import Rswift
import UIKit

/// This `R` struct is generated and contains references to static resources.
struct R: Rswift.Validatable {
  fileprivate static let applicationLocale = hostingBundle.preferredLocalizations.first.flatMap { Locale(identifier: $0) } ?? Locale.current
  fileprivate static let hostingBundle = Bundle(for: R.Class.self)

  /// Find first language and bundle for which the table exists
  fileprivate static func localeBundle(tableName: String, preferredLanguages: [String]) -> (Foundation.Locale, Foundation.Bundle)? {
    // Filter preferredLanguages to localizations, use first locale
    var languages = preferredLanguages
      .map { Locale(identifier: $0) }
      .prefix(1)
      .flatMap { locale -> [String] in
        if hostingBundle.localizations.contains(locale.identifier) {
          if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
            return [locale.identifier, language]
          } else {
            return [locale.identifier]
          }
        } else if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
          return [language]
        } else {
          return []
        }
      }

    // If there's no languages, use development language as backstop
    if languages.isEmpty {
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages = [developmentLocalization]
      }
    } else {
      // Insert Base as second item (between locale identifier and languageCode)
      languages.insert("Base", at: 1)

      // Add development language as backstop
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages.append(developmentLocalization)
      }
    }

    // Find first language for which table exists
    // Note: key might not exist in chosen language (in that case, key will be shown)
    for language in languages {
      if let lproj = hostingBundle.url(forResource: language, withExtension: "lproj"),
         let lbundle = Bundle(url: lproj)
      {
        let strings = lbundle.url(forResource: tableName, withExtension: "strings")
        let stringsdict = lbundle.url(forResource: tableName, withExtension: "stringsdict")

        if strings != nil || stringsdict != nil {
          return (Locale(identifier: language), lbundle)
        }
      }
    }

    // If table is available in main bundle, don't look for localized resources
    let strings = hostingBundle.url(forResource: tableName, withExtension: "strings", subdirectory: nil, localization: nil)
    let stringsdict = hostingBundle.url(forResource: tableName, withExtension: "stringsdict", subdirectory: nil, localization: nil)

    if strings != nil || stringsdict != nil {
      return (applicationLocale, hostingBundle)
    }

    // If table is not found for requested languages, key will be shown
    return nil
  }

  /// Load string from Info.plist file
  fileprivate static func infoPlistString(path: [String], key: String) -> String? {
    var dict = hostingBundle.infoDictionary
    for step in path {
      guard let obj = dict?[step] as? [String: Any] else { return nil }
      dict = obj
    }
    return dict?[key] as? String
  }

  static func validate() throws {
    try font.validate()
    try intern.validate()
  }

  #if os(iOS) || os(tvOS)
  /// This `R.storyboard` struct is generated, and contains static references to 2 storyboards.
  struct storyboard {
    /// Storyboard `LaunchScreen`.
    static let launchScreen = _R.storyboard.launchScreen()
    /// Storyboard `Main`.
    static let main = _R.storyboard.main()

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "LaunchScreen", bundle: ...)`
    static func launchScreen(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.launchScreen)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Main", bundle: ...)`
    static func main(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.main)
    }
    #endif

    fileprivate init() {}
  }
  #endif

  /// This `R.color` struct is generated, and contains static references to 5 colors.
  struct color {
    /// Color `AccentColor`.
    static let accentColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AccentColor")
    /// Color `appTintColor`.
    static let appTintColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "appTintColor")
    /// Color `bgDefault`.
    static let bgDefault = Rswift.ColorResource(bundle: R.hostingBundle, name: "bgDefault")
    /// Color `gradientBottom`.
    static let gradientBottom = Rswift.ColorResource(bundle: R.hostingBundle, name: "gradientBottom")
    /// Color `gradientTop`.
    static let gradientTop = Rswift.ColorResource(bundle: R.hostingBundle, name: "gradientTop")

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AccentColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func accentColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.accentColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "appTintColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func appTintColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.appTintColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "bgDefault", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func bgDefault(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.bgDefault, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "gradientBottom", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func gradientBottom(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.gradientBottom, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "gradientTop", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func gradientTop(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.gradientTop, compatibleWith: traitCollection)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "AccentColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func accentColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.accentColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "appTintColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func appTintColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.appTintColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "bgDefault", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func bgDefault(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.bgDefault.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "gradientBottom", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func gradientBottom(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.gradientBottom.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "gradientTop", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func gradientTop(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.gradientTop.name)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.file` struct is generated, and contains static references to 17 files.
  struct file {
    /// Resource file `Loading_Animation.json`.
    static let loading_AnimationJson = Rswift.FileResource(bundle: R.hostingBundle, name: "Loading_Animation", pathExtension: "json")
    /// Resource file `NunitoSans-Black.ttf`.
    static let nunitoSansBlackTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "NunitoSans-Black", pathExtension: "ttf")
    /// Resource file `NunitoSans-BlackItalic.ttf`.
    static let nunitoSansBlackItalicTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "NunitoSans-BlackItalic", pathExtension: "ttf")
    /// Resource file `NunitoSans-Bold.ttf`.
    static let nunitoSansBoldTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "NunitoSans-Bold", pathExtension: "ttf")
    /// Resource file `NunitoSans-BoldItalic.ttf`.
    static let nunitoSansBoldItalicTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "NunitoSans-BoldItalic", pathExtension: "ttf")
    /// Resource file `NunitoSans-ExtraBold.ttf`.
    static let nunitoSansExtraBoldTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "NunitoSans-ExtraBold", pathExtension: "ttf")
    /// Resource file `NunitoSans-ExtraBoldItalic.ttf`.
    static let nunitoSansExtraBoldItalicTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "NunitoSans-ExtraBoldItalic", pathExtension: "ttf")
    /// Resource file `NunitoSans-ExtraLight.ttf`.
    static let nunitoSansExtraLightTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "NunitoSans-ExtraLight", pathExtension: "ttf")
    /// Resource file `NunitoSans-ExtraLightItalic.ttf`.
    static let nunitoSansExtraLightItalicTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "NunitoSans-ExtraLightItalic", pathExtension: "ttf")
    /// Resource file `NunitoSans-Italic.ttf`.
    static let nunitoSansItalicTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "NunitoSans-Italic", pathExtension: "ttf")
    /// Resource file `NunitoSans-Light.ttf`.
    static let nunitoSansLightTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "NunitoSans-Light", pathExtension: "ttf")
    /// Resource file `NunitoSans-LightItalic.ttf`.
    static let nunitoSansLightItalicTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "NunitoSans-LightItalic", pathExtension: "ttf")
    /// Resource file `NunitoSans-Regular.ttf`.
    static let nunitoSansRegularTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "NunitoSans-Regular", pathExtension: "ttf")
    /// Resource file `NunitoSans-SemiBold.ttf`.
    static let nunitoSansSemiBoldTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "NunitoSans-SemiBold", pathExtension: "ttf")
    /// Resource file `NunitoSans-SemiBoldItalic.ttf`.
    static let nunitoSansSemiBoldItalicTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "NunitoSans-SemiBoldItalic", pathExtension: "ttf")
    /// Resource file `OFL.txt`.
    static let oflTxt = Rswift.FileResource(bundle: R.hostingBundle, name: "OFL", pathExtension: "txt")
    /// Resource file `README.md`.
    static let readmeMd = Rswift.FileResource(bundle: R.hostingBundle, name: "README", pathExtension: "md")

    /// `bundle.url(forResource: "Loading_Animation", withExtension: "json")`
    static func loading_AnimationJson(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.loading_AnimationJson
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "NunitoSans-Black", withExtension: "ttf")`
    static func nunitoSansBlackTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.nunitoSansBlackTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "NunitoSans-BlackItalic", withExtension: "ttf")`
    static func nunitoSansBlackItalicTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.nunitoSansBlackItalicTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "NunitoSans-Bold", withExtension: "ttf")`
    static func nunitoSansBoldTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.nunitoSansBoldTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "NunitoSans-BoldItalic", withExtension: "ttf")`
    static func nunitoSansBoldItalicTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.nunitoSansBoldItalicTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "NunitoSans-ExtraBold", withExtension: "ttf")`
    static func nunitoSansExtraBoldTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.nunitoSansExtraBoldTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "NunitoSans-ExtraBoldItalic", withExtension: "ttf")`
    static func nunitoSansExtraBoldItalicTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.nunitoSansExtraBoldItalicTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "NunitoSans-ExtraLight", withExtension: "ttf")`
    static func nunitoSansExtraLightTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.nunitoSansExtraLightTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "NunitoSans-ExtraLightItalic", withExtension: "ttf")`
    static func nunitoSansExtraLightItalicTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.nunitoSansExtraLightItalicTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "NunitoSans-Italic", withExtension: "ttf")`
    static func nunitoSansItalicTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.nunitoSansItalicTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "NunitoSans-Light", withExtension: "ttf")`
    static func nunitoSansLightTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.nunitoSansLightTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "NunitoSans-LightItalic", withExtension: "ttf")`
    static func nunitoSansLightItalicTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.nunitoSansLightItalicTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "NunitoSans-Regular", withExtension: "ttf")`
    static func nunitoSansRegularTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.nunitoSansRegularTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "NunitoSans-SemiBold", withExtension: "ttf")`
    static func nunitoSansSemiBoldTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.nunitoSansSemiBoldTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "NunitoSans-SemiBoldItalic", withExtension: "ttf")`
    static func nunitoSansSemiBoldItalicTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.nunitoSansSemiBoldItalicTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "OFL", withExtension: "txt")`
    static func oflTxt(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.oflTxt
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "README", withExtension: "md")`
    static func readmeMd(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.readmeMd
      return fileResource.bundle.url(forResource: fileResource)
    }

    fileprivate init() {}
  }

  /// This `R.font` struct is generated, and contains static references to 14 fonts.
  struct font: Rswift.Validatable {
    /// Font `NunitoSans-BlackItalic`.
    static let nunitoSansBlackItalic = Rswift.FontResource(fontName: "NunitoSans-BlackItalic")
    /// Font `NunitoSans-Black`.
    static let nunitoSansBlack = Rswift.FontResource(fontName: "NunitoSans-Black")
    /// Font `NunitoSans-BoldItalic`.
    static let nunitoSansBoldItalic = Rswift.FontResource(fontName: "NunitoSans-BoldItalic")
    /// Font `NunitoSans-Bold`.
    static let nunitoSansBold = Rswift.FontResource(fontName: "NunitoSans-Bold")
    /// Font `NunitoSans-ExtraBoldItalic`.
    static let nunitoSansExtraBoldItalic = Rswift.FontResource(fontName: "NunitoSans-ExtraBoldItalic")
    /// Font `NunitoSans-ExtraBold`.
    static let nunitoSansExtraBold = Rswift.FontResource(fontName: "NunitoSans-ExtraBold")
    /// Font `NunitoSans-ExtraLightItalic`.
    static let nunitoSansExtraLightItalic = Rswift.FontResource(fontName: "NunitoSans-ExtraLightItalic")
    /// Font `NunitoSans-ExtraLight`.
    static let nunitoSansExtraLight = Rswift.FontResource(fontName: "NunitoSans-ExtraLight")
    /// Font `NunitoSans-Italic`.
    static let nunitoSansItalic = Rswift.FontResource(fontName: "NunitoSans-Italic")
    /// Font `NunitoSans-LightItalic`.
    static let nunitoSansLightItalic = Rswift.FontResource(fontName: "NunitoSans-LightItalic")
    /// Font `NunitoSans-Light`.
    static let nunitoSansLight = Rswift.FontResource(fontName: "NunitoSans-Light")
    /// Font `NunitoSans-Regular`.
    static let nunitoSansRegular = Rswift.FontResource(fontName: "NunitoSans-Regular")
    /// Font `NunitoSans-SemiBoldItalic`.
    static let nunitoSansSemiBoldItalic = Rswift.FontResource(fontName: "NunitoSans-SemiBoldItalic")
    /// Font `NunitoSans-SemiBold`.
    static let nunitoSansSemiBold = Rswift.FontResource(fontName: "NunitoSans-SemiBold")

    /// `UIFont(name: "NunitoSans-Black", size: ...)`
    static func nunitoSansBlack(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: nunitoSansBlack, size: size)
    }

    /// `UIFont(name: "NunitoSans-BlackItalic", size: ...)`
    static func nunitoSansBlackItalic(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: nunitoSansBlackItalic, size: size)
    }

    /// `UIFont(name: "NunitoSans-Bold", size: ...)`
    static func nunitoSansBold(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: nunitoSansBold, size: size)
    }

    /// `UIFont(name: "NunitoSans-BoldItalic", size: ...)`
    static func nunitoSansBoldItalic(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: nunitoSansBoldItalic, size: size)
    }

    /// `UIFont(name: "NunitoSans-ExtraBold", size: ...)`
    static func nunitoSansExtraBold(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: nunitoSansExtraBold, size: size)
    }

    /// `UIFont(name: "NunitoSans-ExtraBoldItalic", size: ...)`
    static func nunitoSansExtraBoldItalic(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: nunitoSansExtraBoldItalic, size: size)
    }

    /// `UIFont(name: "NunitoSans-ExtraLight", size: ...)`
    static func nunitoSansExtraLight(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: nunitoSansExtraLight, size: size)
    }

    /// `UIFont(name: "NunitoSans-ExtraLightItalic", size: ...)`
    static func nunitoSansExtraLightItalic(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: nunitoSansExtraLightItalic, size: size)
    }

    /// `UIFont(name: "NunitoSans-Italic", size: ...)`
    static func nunitoSansItalic(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: nunitoSansItalic, size: size)
    }

    /// `UIFont(name: "NunitoSans-Light", size: ...)`
    static func nunitoSansLight(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: nunitoSansLight, size: size)
    }

    /// `UIFont(name: "NunitoSans-LightItalic", size: ...)`
    static func nunitoSansLightItalic(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: nunitoSansLightItalic, size: size)
    }

    /// `UIFont(name: "NunitoSans-Regular", size: ...)`
    static func nunitoSansRegular(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: nunitoSansRegular, size: size)
    }

    /// `UIFont(name: "NunitoSans-SemiBold", size: ...)`
    static func nunitoSansSemiBold(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: nunitoSansSemiBold, size: size)
    }

    /// `UIFont(name: "NunitoSans-SemiBoldItalic", size: ...)`
    static func nunitoSansSemiBoldItalic(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: nunitoSansSemiBoldItalic, size: size)
    }

    static func validate() throws {
      if R.font.nunitoSansBlack(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'NunitoSans-Black' could not be loaded, is 'NunitoSans-Black.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.nunitoSansBlackItalic(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'NunitoSans-BlackItalic' could not be loaded, is 'NunitoSans-BlackItalic.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.nunitoSansBold(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'NunitoSans-Bold' could not be loaded, is 'NunitoSans-Bold.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.nunitoSansBoldItalic(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'NunitoSans-BoldItalic' could not be loaded, is 'NunitoSans-BoldItalic.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.nunitoSansExtraBold(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'NunitoSans-ExtraBold' could not be loaded, is 'NunitoSans-ExtraBold.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.nunitoSansExtraBoldItalic(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'NunitoSans-ExtraBoldItalic' could not be loaded, is 'NunitoSans-ExtraBoldItalic.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.nunitoSansExtraLight(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'NunitoSans-ExtraLight' could not be loaded, is 'NunitoSans-ExtraLight.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.nunitoSansExtraLightItalic(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'NunitoSans-ExtraLightItalic' could not be loaded, is 'NunitoSans-ExtraLightItalic.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.nunitoSansItalic(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'NunitoSans-Italic' could not be loaded, is 'NunitoSans-Italic.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.nunitoSansLight(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'NunitoSans-Light' could not be loaded, is 'NunitoSans-Light.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.nunitoSansLightItalic(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'NunitoSans-LightItalic' could not be loaded, is 'NunitoSans-LightItalic.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.nunitoSansRegular(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'NunitoSans-Regular' could not be loaded, is 'NunitoSans-Regular.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.nunitoSansSemiBold(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'NunitoSans-SemiBold' could not be loaded, is 'NunitoSans-SemiBold.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.nunitoSansSemiBoldItalic(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'NunitoSans-SemiBoldItalic' could not be loaded, is 'NunitoSans-SemiBoldItalic.ttf' added to the UIAppFonts array in this targets Info.plist?") }
    }

    fileprivate init() {}
  }

  /// This `R.id` struct is generated, and contains static references to accessibility identifiers.
  struct id {
    struct alertCustomViewController {
      /// Accessibility identifier `viewAlert`.
      static let viewAlert: String = "viewAlert"

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  /// This `R.image` struct is generated, and contains static references to 18 images.
  struct image {
    /// Image `ic-back`.
    static let icBack = Rswift.ImageResource(bundle: R.hostingBundle, name: "ic-back")
    /// Image `ic-bg`.
    static let icBg = Rswift.ImageResource(bundle: R.hostingBundle, name: "ic-bg")
    /// Image `ic-fivefilm`.
    static let icFivefilm = Rswift.ImageResource(bundle: R.hostingBundle, name: "ic-fivefilm")
    /// Image `ic-heart-orange`.
    static let icHeartOrange = Rswift.ImageResource(bundle: R.hostingBundle, name: "ic-heart-orange")
    /// Image `ic-heart-white`.
    static let icHeartWhite = Rswift.ImageResource(bundle: R.hostingBundle, name: "ic-heart-white")
    /// Image `ic-like-orange`.
    static let icLikeOrange = Rswift.ImageResource(bundle: R.hostingBundle, name: "ic-like-orange")
    /// Image `ic-like-white`.
    static let icLikeWhite = Rswift.ImageResource(bundle: R.hostingBundle, name: "ic-like-white")
    /// Image `ic-logo-nav`.
    static let icLogoNav = Rswift.ImageResource(bundle: R.hostingBundle, name: "ic-logo-nav")
    /// Image `ic-movie-default`.
    static let icMovieDefault = Rswift.ImageResource(bundle: R.hostingBundle, name: "ic-movie-default")
    /// Image `ic-movie-test`.
    static let icMovieTest = Rswift.ImageResource(bundle: R.hostingBundle, name: "ic-movie-test")
    /// Image `ic-notfound`.
    static let icNotfound = Rswift.ImageResource(bundle: R.hostingBundle, name: "ic-notfound")
    /// Image `ic-reload`.
    static let icReload = Rswift.ImageResource(bundle: R.hostingBundle, name: "ic-reload")
    /// Image `ic-search`.
    static let icSearch = Rswift.ImageResource(bundle: R.hostingBundle, name: "ic-search")
    /// Image `ic-star`.
    static let icStar = Rswift.ImageResource(bundle: R.hostingBundle, name: "ic-star")
    /// Image `ic-tab-home-active`.
    static let icTabHomeActive = Rswift.ImageResource(bundle: R.hostingBundle, name: "ic-tab-home-active")
    /// Image `ic-tab-home`.
    static let icTabHome = Rswift.ImageResource(bundle: R.hostingBundle, name: "ic-tab-home")
    /// Image `ic-tab-personal-active`.
    static let icTabPersonalActive = Rswift.ImageResource(bundle: R.hostingBundle, name: "ic-tab-personal-active")
    /// Image `ic-tab-personal`.
    static let icTabPersonal = Rswift.ImageResource(bundle: R.hostingBundle, name: "ic-tab-personal")

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ic-back", bundle: ..., traitCollection: ...)`
    static func icBack(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icBack, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ic-bg", bundle: ..., traitCollection: ...)`
    static func icBg(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icBg, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ic-fivefilm", bundle: ..., traitCollection: ...)`
    static func icFivefilm(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icFivefilm, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ic-heart-orange", bundle: ..., traitCollection: ...)`
    static func icHeartOrange(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icHeartOrange, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ic-heart-white", bundle: ..., traitCollection: ...)`
    static func icHeartWhite(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icHeartWhite, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ic-like-orange", bundle: ..., traitCollection: ...)`
    static func icLikeOrange(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icLikeOrange, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ic-like-white", bundle: ..., traitCollection: ...)`
    static func icLikeWhite(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icLikeWhite, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ic-logo-nav", bundle: ..., traitCollection: ...)`
    static func icLogoNav(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icLogoNav, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ic-movie-default", bundle: ..., traitCollection: ...)`
    static func icMovieDefault(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icMovieDefault, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ic-movie-test", bundle: ..., traitCollection: ...)`
    static func icMovieTest(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icMovieTest, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ic-notfound", bundle: ..., traitCollection: ...)`
    static func icNotfound(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icNotfound, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ic-reload", bundle: ..., traitCollection: ...)`
    static func icReload(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icReload, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ic-search", bundle: ..., traitCollection: ...)`
    static func icSearch(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icSearch, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ic-star", bundle: ..., traitCollection: ...)`
    static func icStar(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icStar, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ic-tab-home", bundle: ..., traitCollection: ...)`
    static func icTabHome(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icTabHome, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ic-tab-home-active", bundle: ..., traitCollection: ...)`
    static func icTabHomeActive(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icTabHomeActive, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ic-tab-personal", bundle: ..., traitCollection: ...)`
    static func icTabPersonal(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icTabPersonal, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ic-tab-personal-active", bundle: ..., traitCollection: ...)`
    static func icTabPersonalActive(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icTabPersonalActive, compatibleWith: traitCollection)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.nib` struct is generated, and contains static references to 14 nibs.
  struct nib {
    /// Nib `AlertCustomViewController`.
    static let alertCustomViewController = _R.nib._AlertCustomViewController()
    /// Nib `CustomPageVC`.
    static let customPageVC = _R.nib._CustomPageVC()
    /// Nib `FavoriteMovieVC`.
    static let favoriteMovieVC = _R.nib._FavoriteMovieVC()
    /// Nib `HomeVC`.
    static let homeVC = _R.nib._HomeVC()
    /// Nib `ItemHeaderCell`.
    static let itemHeaderCell = _R.nib._ItemHeaderCell()
    /// Nib `ItemHomeLoadMoreCell`.
    static let itemHomeLoadMoreCell = _R.nib._ItemHomeLoadMoreCell()
    /// Nib `ItemLoadMoreTableViewCell`.
    static let itemLoadMoreTableViewCell = _R.nib._ItemLoadMoreTableViewCell()
    /// Nib `ItemMovieCell`.
    static let itemMovieCell = _R.nib._ItemMovieCell()
    /// Nib `ItemNotFoundMovieCell`.
    static let itemNotFoundMovieCell = _R.nib._ItemNotFoundMovieCell()
    /// Nib `ItemSearchMovieCell`.
    static let itemSearchMovieCell = _R.nib._ItemSearchMovieCell()
    /// Nib `ListFilmVC`.
    static let listFilmVC = _R.nib._ListFilmVC()
    /// Nib `MainTabVC`.
    static let mainTabVC = _R.nib._MainTabVC()
    /// Nib `MovieDetailVC`.
    static let movieDetailVC = _R.nib._MovieDetailVC()
    /// Nib `SearchMoviesVC`.
    static let searchMoviesVC = _R.nib._SearchMoviesVC()

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "AlertCustomViewController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.alertCustomViewController) instead")
    static func alertCustomViewController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.alertCustomViewController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "CustomPageVC", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.customPageVC) instead")
    static func customPageVC(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.customPageVC)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "FavoriteMovieVC", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.favoriteMovieVC) instead")
    static func favoriteMovieVC(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.favoriteMovieVC)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "HomeVC", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.homeVC) instead")
    static func homeVC(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.homeVC)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ItemHeaderCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.itemHeaderCell) instead")
    static func itemHeaderCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.itemHeaderCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ItemHomeLoadMoreCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.itemHomeLoadMoreCell) instead")
    static func itemHomeLoadMoreCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.itemHomeLoadMoreCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ItemLoadMoreTableViewCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.itemLoadMoreTableViewCell) instead")
    static func itemLoadMoreTableViewCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.itemLoadMoreTableViewCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ItemMovieCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.itemMovieCell) instead")
    static func itemMovieCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.itemMovieCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ItemNotFoundMovieCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.itemNotFoundMovieCell) instead")
    static func itemNotFoundMovieCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.itemNotFoundMovieCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ItemSearchMovieCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.itemSearchMovieCell) instead")
    static func itemSearchMovieCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.itemSearchMovieCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ListFilmVC", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.listFilmVC) instead")
    static func listFilmVC(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.listFilmVC)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "MainTabVC", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.mainTabVC) instead")
    static func mainTabVC(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.mainTabVC)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "MovieDetailVC", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.movieDetailVC) instead")
    static func movieDetailVC(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.movieDetailVC)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "SearchMoviesVC", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.searchMoviesVC) instead")
    static func searchMoviesVC(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.searchMoviesVC)
    }
    #endif

    static func alertCustomViewController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.alertCustomViewController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func customPageVC(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.customPageVC.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func favoriteMovieVC(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.favoriteMovieVC.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func homeVC(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.homeVC.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func itemHeaderCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> ItemHeaderCell? {
      return R.nib.itemHeaderCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? ItemHeaderCell
    }

    static func itemHomeLoadMoreCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> ItemHomeLoadMoreCell? {
      return R.nib.itemHomeLoadMoreCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? ItemHomeLoadMoreCell
    }

    static func itemLoadMoreTableViewCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> ItemLoadMoreTableViewCell? {
      return R.nib.itemLoadMoreTableViewCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? ItemLoadMoreTableViewCell
    }

    static func itemMovieCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> ItemMovieCell? {
      return R.nib.itemMovieCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? ItemMovieCell
    }

    static func itemNotFoundMovieCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> ItemNotFoundMovieCell? {
      return R.nib.itemNotFoundMovieCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? ItemNotFoundMovieCell
    }

    static func itemSearchMovieCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> ItemSearchMovieCell? {
      return R.nib.itemSearchMovieCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? ItemSearchMovieCell
    }

    static func listFilmVC(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.listFilmVC.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func mainTabVC(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.mainTabVC.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func movieDetailVC(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.movieDetailVC.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func searchMoviesVC(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.searchMoviesVC.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    fileprivate init() {}
  }

  /// This `R.reuseIdentifier` struct is generated, and contains static references to 5 reuse identifiers.
  struct reuseIdentifier {
    /// Reuse identifier `ItemHeaderCell`.
    static let itemHeaderCell: Rswift.ReuseIdentifier<ItemHeaderCell> = Rswift.ReuseIdentifier(identifier: "ItemHeaderCell")
    /// Reuse identifier `ItemLoadMoreTableViewCell`.
    static let itemLoadMoreTableViewCell: Rswift.ReuseIdentifier<ItemLoadMoreTableViewCell> = Rswift.ReuseIdentifier(identifier: "ItemLoadMoreTableViewCell")
    /// Reuse identifier `ItemMovieCell`.
    static let itemMovieCell: Rswift.ReuseIdentifier<ItemMovieCell> = Rswift.ReuseIdentifier(identifier: "ItemMovieCell")
    /// Reuse identifier `ItemNotFoundMovieCell`.
    static let itemNotFoundMovieCell: Rswift.ReuseIdentifier<ItemNotFoundMovieCell> = Rswift.ReuseIdentifier(identifier: "ItemNotFoundMovieCell")
    /// Reuse identifier `ItemSearchMovieCell`.
    static let itemSearchMovieCell: Rswift.ReuseIdentifier<ItemSearchMovieCell> = Rswift.ReuseIdentifier(identifier: "ItemSearchMovieCell")

    fileprivate init() {}
  }

  fileprivate struct intern: Rswift.Validatable {
    fileprivate static func validate() throws {
      try _R.validate()
    }

    fileprivate init() {}
  }

  fileprivate class Class {}

  fileprivate init() {}
}

struct _R: Rswift.Validatable {
  static func validate() throws {
    #if os(iOS) || os(tvOS)
    try nib.validate()
    #endif
    #if os(iOS) || os(tvOS)
    try storyboard.validate()
    #endif
  }

  #if os(iOS) || os(tvOS)
  struct nib: Rswift.Validatable {
    static func validate() throws {
      try _FavoriteMovieVC.validate()
      try _HomeVC.validate()
      try _ItemHomeLoadMoreCell.validate()
      try _ItemLoadMoreTableViewCell.validate()
      try _ItemMovieCell.validate()
      try _ItemNotFoundMovieCell.validate()
      try _ItemSearchMovieCell.validate()
      try _MovieDetailVC.validate()
      try _SearchMoviesVC.validate()
    }

    struct _AlertCustomViewController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "AlertCustomViewController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _CustomPageVC: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "CustomPageVC"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _FavoriteMovieVC: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "FavoriteMovieVC"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      static func validate() throws {
        if UIKit.UIImage(named: "ic-bg", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-bg' is used in nib 'FavoriteMovieVC', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ic-search", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-search' is used in nib 'FavoriteMovieVC', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "appTintColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'appTintColor' is used in nib 'FavoriteMovieVC', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _HomeVC: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "HomeVC"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      static func validate() throws {
        if UIKit.UIImage(named: "ic-bg", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-bg' is used in nib 'HomeVC', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ic-logo-nav", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-logo-nav' is used in nib 'HomeVC', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ic-search", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-search' is used in nib 'HomeVC', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "appTintColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'appTintColor' is used in nib 'HomeVC', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _ItemHeaderCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType {
      typealias ReusableType = ItemHeaderCell

      let bundle = R.hostingBundle
      let identifier = "ItemHeaderCell"
      let name = "ItemHeaderCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> ItemHeaderCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? ItemHeaderCell
      }

      fileprivate init() {}
    }

    struct _ItemHomeLoadMoreCell: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "ItemHomeLoadMoreCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> ItemHomeLoadMoreCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? ItemHomeLoadMoreCell
      }

      static func validate() throws {
        if UIKit.UIImage(named: "ic-reload", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-reload' is used in nib 'ItemHomeLoadMoreCell', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "appTintColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'appTintColor' is used in nib 'ItemHomeLoadMoreCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _ItemLoadMoreTableViewCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType, Rswift.Validatable {
      typealias ReusableType = ItemLoadMoreTableViewCell

      let bundle = R.hostingBundle
      let identifier = "ItemLoadMoreTableViewCell"
      let name = "ItemLoadMoreTableViewCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> ItemLoadMoreTableViewCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? ItemLoadMoreTableViewCell
      }

      static func validate() throws {
        if UIKit.UIImage(named: "ic-reload", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-reload' is used in nib 'ItemLoadMoreTableViewCell', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "appTintColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'appTintColor' is used in nib 'ItemLoadMoreTableViewCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _ItemMovieCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType, Rswift.Validatable {
      typealias ReusableType = ItemMovieCell

      let bundle = R.hostingBundle
      let identifier = "ItemMovieCell"
      let name = "ItemMovieCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> ItemMovieCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? ItemMovieCell
      }

      static func validate() throws {
        if UIKit.UIImage(named: "ic-heart-white", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-heart-white' is used in nib 'ItemMovieCell', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ic-like-white", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-like-white' is used in nib 'ItemMovieCell', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ic-movie-test", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-movie-test' is used in nib 'ItemMovieCell', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ic-star", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-star' is used in nib 'ItemMovieCell', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "appTintColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'appTintColor' is used in nib 'ItemMovieCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _ItemNotFoundMovieCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType, Rswift.Validatable {
      typealias ReusableType = ItemNotFoundMovieCell

      let bundle = R.hostingBundle
      let identifier = "ItemNotFoundMovieCell"
      let name = "ItemNotFoundMovieCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> ItemNotFoundMovieCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? ItemNotFoundMovieCell
      }

      static func validate() throws {
        if UIKit.UIImage(named: "ic-notfound", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-notfound' is used in nib 'ItemNotFoundMovieCell', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "appTintColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'appTintColor' is used in nib 'ItemNotFoundMovieCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _ItemSearchMovieCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType, Rswift.Validatable {
      typealias ReusableType = ItemSearchMovieCell

      let bundle = R.hostingBundle
      let identifier = "ItemSearchMovieCell"
      let name = "ItemSearchMovieCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> ItemSearchMovieCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? ItemSearchMovieCell
      }

      static func validate() throws {
        if UIKit.UIImage(named: "ic-heart-white", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-heart-white' is used in nib 'ItemSearchMovieCell', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ic-like-white", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-like-white' is used in nib 'ItemSearchMovieCell', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ic-movie-test", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-movie-test' is used in nib 'ItemSearchMovieCell', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ic-star", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-star' is used in nib 'ItemSearchMovieCell', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "appTintColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'appTintColor' is used in nib 'ItemSearchMovieCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _ListFilmVC: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "ListFilmVC"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _MainTabVC: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "MainTabVC"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _MovieDetailVC: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "MovieDetailVC"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      static func validate() throws {
        if UIKit.UIImage(named: "ic-back", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-back' is used in nib 'MovieDetailVC', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ic-bg", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-bg' is used in nib 'MovieDetailVC', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ic-heart-white", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-heart-white' is used in nib 'MovieDetailVC', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ic-like-white", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-like-white' is used in nib 'MovieDetailVC', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ic-movie-test", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-movie-test' is used in nib 'MovieDetailVC', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ic-star", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-star' is used in nib 'MovieDetailVC', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "appTintColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'appTintColor' is used in nib 'MovieDetailVC', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _SearchMoviesVC: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "SearchMoviesVC"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      static func validate() throws {
        if UIKit.UIImage(named: "ic-back", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-back' is used in nib 'SearchMoviesVC', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ic-bg", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-bg' is used in nib 'SearchMoviesVC', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ic-search", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-search' is used in nib 'SearchMoviesVC', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "appTintColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'appTintColor' is used in nib 'SearchMoviesVC', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }
  #endif

  #if os(iOS) || os(tvOS)
  struct storyboard: Rswift.Validatable {
    static func validate() throws {
      #if os(iOS) || os(tvOS)
      try launchScreen.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try main.validate()
      #endif
    }

    #if os(iOS) || os(tvOS)
    struct launchScreen: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UIViewController

      let bundle = R.hostingBundle
      let name = "LaunchScreen"

      static func validate() throws {
        if UIKit.UIImage(named: "ic-bg", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-bg' is used in storyboard 'LaunchScreen', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ic-fivefilm", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-fivefilm' is used in storyboard 'LaunchScreen', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ic-logo-nav", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-logo-nav' is used in storyboard 'LaunchScreen', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "bgDefault", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'bgDefault' is used in storyboard 'LaunchScreen', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct main: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = ViewController

      let bundle = R.hostingBundle
      let name = "Main"

      static func validate() throws {
        if UIKit.UIImage(named: "ic-bg", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-bg' is used in storyboard 'Main', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ic-fivefilm", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-fivefilm' is used in storyboard 'Main', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ic-logo-nav", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ic-logo-nav' is used in storyboard 'Main', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "bgDefault", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'bgDefault' is used in storyboard 'Main', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }
    #endif

    fileprivate init() {}
  }
  #endif

  fileprivate init() {}
}
